//===========================PRINTING @ ===============================
//fn F1 to include schools header file
#include <unistd.h>
//FUNCTION DECLARATION: 

int ft_putchar(char c){
    write (1, &c, 1);
    return (0);
}


int main ()
{
    ft_putchar ('@');
    ft_putchar ('\n');

    return (0);
}
/*Data type - NAME - (data type1 - NAME param1, data type2 - NAME param2, ...)

Array is a succession of objects of the same type in the memory. 

type name []; e.g. 

int tab[42]; 

- index goes from 0 - 41. declaration of an array that can contain - reserved 42 [12] - 13th int ints in the memory

Struct
    struct struct_name
    {
        type name;
        type name;
    };
    
    e.g.
    
    struct s_fortytwo
    {
        int a;
        char b [21];
    }

    struct struct_name  name;
    struct s_fortytwo a;


//BLOCK:

//{
    
    //Local variable declaration. Outside of the function they dont exist.
    
    //instructions;
//} 

int main ()
{
    
}

EXPRESSIONS:
    NUMERICAL VALUES: 0 42 0X1A 010
    VARIABLES: int a; b[18]---it will look for the 19th element; sft_var.a ------element a in the structure sft_var.
    FUNCTION CALLS: 
    COMPUTATIONS: 1+3 -(A*42 + B[0])/SUM(21,34-B[10})
    ASSIGNATION a=42 b[2+a]=sum 912,30)
    COMPARISONS: == != < >  <= >= || - or && - and ! negation (1 TRUE, 0 FALSE)
    BINARY OPERATORS: >> << | & ^
    SPECIALS 'A' - ASCII
        sizeof(tyoe)
        &a (address)
        exp1?exp2:exp3
    STRINGS: series of characters "hello forty-two"
    POINTER: it store address of another variable int*p; stores variable of type int. Once declare a pointer write p=&a see the address of a in p then we use *p=1 its the same as writing a=1 same memory area, same address and same type. *name object of type, the address stored in name.
        int tab [42]; p&(tab[])
    CONTROL INSTRUCTIONS:
        if: 
        
        if (expression) if 0 it doesnt do anything, else execute instruction
                instruction
                
        if (expression)
                instruction
            else
                instruction
                
        while:
        
            while (expression) ---loop
                instruction
                
        return (expression);
        return;
        
        
 gcc -o nameofnew nameofnew.c  ./jour02 */
